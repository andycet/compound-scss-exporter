import { DocumentationLegacyGroupBehavior } from "../enums/SDKDocumentationLegacyGroupBehavior";
import { DocumentationLegacyItemType } from "../enums/SDKDocumentationLegacyItemType";
import { DocumentationLegacyItem, DocumentationLegacyItemModel } from "./SDKDocumentationLegacyItem";
import { DocumentationLegacyPage } from "./SDKDocumentationLegacyPage";
export type DocumentationLegacyGroupModel = {
    isRoot: boolean;
    childrenIds: Array<string>;
    groupBehavior: DocumentationLegacyGroupBehavior;
} & DocumentationLegacyItemModel;
export declare class DocumentationLegacyGroup extends DocumentationLegacyItem {
    /** If true, this is unique within documentation (just one) that contains all top-level objects and is root of the docs tree (root > groups > items > blocks ...) */
    isRoot: boolean;
    /** IDs of items belonging to the documentation group. Can be page or group */
    childrenIds: Array<string>;
    /** Items belonging to the documentation group. Can be page or group */
    children: Array<DocumentationLegacyItem>;
    type: DocumentationLegacyItemType.group;
    /** Parent group reference */
    parent: DocumentationLegacyGroup | null;
    /** Signifies how the group should behave. If set to "tabs", group behaves as "page", but contains multiple tabbed pages inside it. "Group" signifies virtual group used for content structuring */
    groupBehavior: DocumentationLegacyGroupBehavior;
    /** Children filtered to be only groups */
    get subgroups(): Array<DocumentationLegacyGroup>;
    /** Children filtered to be only pages */
    get pages(): Array<DocumentationLegacyPage>;
    /** Internal */
    relativeFirstPageUrl: string | null;
    /** Internal */
    deployedFirstPageUrl: string | null;
    constructor(model: DocumentationLegacyGroupModel);
    addChild(item: DocumentationLegacyItem): void;
    addChildren(groups: Array<DocumentationLegacyItem>): void;
    setParent(parent: DocumentationLegacyGroup | null): void;
    /** Internal: Modifies object with new paths. Don't use outside SDK environment as it doesn't propagate the data back to source */
    internalOverridePaths(relative: string | null, deployed: string | null): void;
    /** Retrieve relative page path without the associated domain for the first page in the group. Will work even when documentation was not yet deployed */
    relativeDocsPageUrl(): string | null;
    /** Retrieve page url for the first page in the group, if the documentation was already deployed (either default or custom domain) */
    deployedDocsPageUrl(): string | null;
}
