import { Acl } from "../../model/acl/SDKAcl";
import { Asset } from "../../model/assets/SDKAsset";
import { RenderedAsset } from "../../model/assets/SDKRenderedAsset";
import { Brand, BrandUpdateModel } from "../../model/base/SDKBrand";
import { DesignSystem, DesignSystemSwitcher } from "../../model/base/SDKDesignSystem";
import { DesignSystemVersion, DesignSystemVersionUpdateModel } from "../../model/base/SDKDesignSystemVersion";
import { DocumentationLegacy, DocumentationLegacyModel } from "../../model/base/SDKDocumentationLegacy";
import { Component } from "../../model/components/SDKComponent";
import { DesignComponent } from "../../model/components/SDKDesignComponent";
import { DocumentationLegacyGroup, DocumentationLegacyGroupModel } from "../../model/documentation/SDKDocumentationLegacyGroup";
import { DocumentationLegacyItem } from "../../model/documentation/SDKDocumentationLegacyItem";
import { DocumentationLegacyPage, DocumentationLegacyPageModel } from "../../model/documentation/SDKDocumentationLegacyPage";
import { ElementDataView } from "../../model/elements/SDKElementDataView";
import { ElementDataViewColumn } from "../../model/elements/SDKElementDataViewColumn";
import { ElementProperty, ElementPropertyCreationModel, ElementPropertyTargetElementType, ElementPropertyUpdateModel } from "../../model/elements/SDKElementProperty";
import { ElementPropertyValue } from "../../model/elements/values/SDKElementPropertyValue";
import { DocumentationEnvironment } from "../../model/enums/SDKDocumentationEnvironment";
import { TokenType } from "../../model/enums/SDKTokenType";
import { ExporterCustomBlock } from "../../model/exporters/custom_blocks/SDKExporterCustomBlock";
import { ExporterCustomBlockVariant } from "../../model/exporters/custom_blocks/SDKExporterCustomBlockVariant";
import { ExporterConfigurationProperty } from "../../model/exporters/custom_properties/SDKExporterConfigurationProperty";
import { Exporter } from "../../model/exporters/SDKExporter";
import { Pipeline } from "../../model/exporters/SDKPipeline";
import { AssetGroup } from "../../model/groups/SDKAssetGroup";
import { ComponentGroup } from "../../model/groups/SDKComponentGroup";
import { DesignComponentGroup } from "../../model/groups/SDKDesignComponentGroup";
import { TokenGroup } from "../../model/groups/SDKTokenGroup";
import { ImportJob } from "../../model/jobs/SDKImportJob";
import { Membership } from "../../model/membership/SDKMembership";
import { CustomDomain } from "../../model/support/SDKCustomDomain";
import { Source, SourceRemoteModelCloud } from "../../model/support/SDKSource";
import { TokenTheme } from "../../model/themes/SDKTokenTheme";
import { Token } from "../../model/tokens/SDKToken";
import { User } from "../../model/users/SDKUser";
import { UserMembership } from "../../model/users/SDKUserMembership";
import { UserProfileUpdateModel } from "../../model/users/SDKUserProfile";
import { Workspace } from "../../model/workspaces/SDKWorkspace";
import { WorkspaceIPWhitelistSettings, WorkspaceIPWhitelistSettingsUpdateModel } from "../../model/workspaces/SDKWorkspaceIPWhitelistSettings";
import { WorkspaceNPMRegistrySettings, WorkspaceNPMRegistrySettingsUpdateModel } from "../../model/workspaces/SDKWorkspaceNPMRegistrySettings";
import { WorkspaceOnboarding, WorkspaceOnboardingUpdateModel } from "../../model/workspaces/SDKWorkspaceOnboarding";
import { SubscriptionProductFeatures } from "../../model/workspaces/SDKWorkspaceProductFeatures";
import { WorkspaceProfileUpdateModel } from "../../model/workspaces/SDKWorkspaceProfile";
import { WorkspaceSSOSettings, WorkspaceSSOSettingsUpdateModel } from "../../model/workspaces/SDKWorkspaceSSOSettings";
import { ComponentUpdateTransactionData, TokenUpdateTransactionData } from "../areas/SDKAreaBulkOperations";
import { RenderedAssetRequestSettings } from "./requests/SDKDataCoreRenderRequests";
import { DataBridge } from "./SDKDataBridge";
import { RequestInfo, RequestInit, Response } from "node-fetch";
export declare class DataCore {
    /** Read part of the network calls */
    private read;
    /** Write part of the network calls */
    private write;
    /** Asset generation part of the network calls */
    private render;
    /** Bridge */
    private bridge;
    constructor(bridge: DataBridge);
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    /** Remote: Get information about currently logged in user */
    currentUser(): Promise<User>;
    /** Remote: Get information about a specific user */
    user(userId: string): Promise<User>;
    /** Remote: Get information about all workspaces user has access to, including which role they play */
    memberships(userId: string): Promise<Array<Membership>>;
    /** Remote: Get information about all workspaces user has access to, including which role they play */
    userMemberships(workspaceId: string): Promise<Array<UserMembership>>;
    subscriptionProductFeatures(): Promise<SubscriptionProductFeatures>;
    acls(): Promise<Acl>;
    /** Deletes the user by id. Can only really delete its own user */
    deleteUser(userId: string): Promise<void>;
    /** Checks whether user can be deleted or not. Can only really check its own user */
    canDeleteUser(userId: string): Promise<boolean>;
    /** Logs out user. Can only really logout its own user */
    logoutCurrentUser(): Promise<void>;
    /** Updates the user profile of specified user. Can only really update its own user */
    updateUserProfile(userId: string, profile: UserProfileUpdateModel): Promise<void>;
    /** Updates the avatar of the current user */
    updateUserAvatar(userId: string, avatar: File): Promise<void>;
    /** Updates the avatar of the current user */
    deleteUserAvatar(userId: string): Promise<void>;
    /** Download all necessary data for element property definitions and retrieve them resolved */
    elementPropertyDefinitions(designSystemId: string, versionId: string, type: ElementPropertyTargetElementType): Promise<Array<ElementProperty>>;
    /** Download all necessary data for element property values and retrieve them resolved */
    elementPropertyValues(designSystemId: string, versionId: string): Promise<Array<ElementPropertyValue>>;
    /** Download all necessary data for element views and retrieve them resolved */
    elementViews(designSystemId: string, versionId: string, type: ElementPropertyTargetElementType): Promise<Array<ElementDataView>>;
    /** Download all necessary data for tokens and retrieve them resolved */
    tokens(designSystemId: string, versionId: string, filter?: {
        type?: TokenType;
        brandId?: string;
    }): Promise<Array<Token>>;
    /** Download all necesssary data for token usage and retrieve them resolved */
    getTokenUsage(designSystemId: string, versionId: string, idInVersion: string): Promise<{
        tokens: Array<string>;
        components: Array<string>;
        documentationPages: Array<string>;
    }>;
    /** Write new token to remote */
    createToken(designSystemId: string, versionId: string, token: Token, parentId: string): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Update existing token in remote */
    updateToken(designSystemId: string, versionId: string, token: Token): Promise<void>;
    /** Write new token group to remote */
    createTokenGroup(designSystemId: string, versionId: string, group: TokenGroup, parentId: string): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Update existing token in remote */
    updateTokenGroup(designSystemId: string, versionId: string, group: TokenGroup): Promise<void>;
    /** Download all necessary data for token groups and retrieve them resolved */
    tokenGroups(designSystemId: string, versionId: string, filter?: {
        type?: TokenType;
        brandId?: string;
    }): Promise<Array<TokenGroup>>;
    /** Write new token theme to remote */
    createTokenTheme(designSystemId: string, versionId: string, theme: TokenTheme): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Download all necessary data for token themes and retrieve them resolved */
    themes(designSystemId: string, versionId: string): Promise<Array<TokenTheme>>;
    /** Update existing token theme in remote */
    updateTokenTheme(designSystemId: string, versionId: string, theme: TokenTheme): Promise<void>;
    /** Write the tokens to remote */
    writeTokenData(designSystemId: string, versionId: string, tokens: Array<Token>, groups: Array<TokenGroup>, deleteTokens: Array<Token>, deleteGroups: Array<TokenGroup>): Promise<void>;
    writeTokenThemeData(designSystemId: string, versionId: string, theme: TokenTheme): Promise<void>;
    /** Delete token from remote */
    deleteToken(designSystemId: string, versionId: string, tokenId: string): Promise<void>;
    /** Delete group from remote */
    ungroupTokenGroup(designSystemId: string, versionId: string, groupId: string): Promise<void>;
    /** Delete group from remote */
    deleteTokenGroup(designSystemId: string, versionId: string, tokenGroupToDelete: TokenGroup, tokens: Array<Token>, tokenGroups: Array<TokenGroup>): Promise<void>;
    private itemsToDeleteFromGroup;
    /** Update token property at remote */
    updateTokenPropertyValue(designSystemId: string, versionId: string, newValue: string | boolean | number, token: Token, property: ElementProperty): Promise<void>;
    /** Delete token property in remote */
    deleteTokenPropertyValue(designSystemId: string, versionId: string, valueId: string): Promise<void>;
    /** Create a custom property in remote */
    createTokenProperty(designSystemId: string, versionId: string, model: ElementPropertyCreationModel): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Create a page within documentation */
    createDocumentationPage(designSystemId: string, versionId: string, parentItemPersistentId: string, newTitle?: string): Promise<DocumentationLegacyPage>;
    /** Create a group within documentation */
    createDocumentationGroup(designSystemId: string, versionId: string, parentItemPersistentId: string, data: Partial<DocumentationLegacyGroupModel>): Promise<DocumentationLegacyGroup>;
    /** Ungroup a documentaiton group */
    ungroupDocumentationGroup(designSystemId: string, versionId: string, groupId: string): Promise<void>;
    /** Updates a documentation group */
    updateDocumentationGroup(designSystemId: string, versionId: string, group: DocumentationLegacyGroup, updateModel: Partial<DocumentationLegacyGroupModel>): Promise<DocumentationLegacyGroup>;
    /** Updates a documentation page or tab */
    updateDocumentationPageOrTab(designSystemId: string, versionId: string, page: DocumentationLegacyPage, updateModel: Partial<DocumentationLegacyPageModel>): Promise<DocumentationLegacyPage>;
    /** Duplicate a documentation page or tab */
    duplicateDocumentationPageOrTab(designSystemId: string, versionId: string, idInVersion: string): Promise<void>;
    /** Delete a documentation page */
    deleteDocumentationPage(designSystemId: string, versionId: string, idInVerision: string): Promise<void>;
    /** Delete a documentation group */
    deleteDocumentationGroup(designSystemId: string, versionId: string, group: DocumentationLegacyGroup): Promise<void>;
    /** Delete a documentation group and tree inside it */
    deleteDocumentationGroupAndTree(designSystemId: string, versionId: string, group: DocumentationLegacyGroup): Promise<void>;
    /** Create a custom property in remote */
    updateTokenProperty(designSystemId: string, versionId: string, propertyIdInVersion: string, model: ElementPropertyUpdateModel): Promise<void>;
    /** Delete a custom property in remote */
    deleteTokenProperty(designSystemId: string, versionId: string, propertyId: string): Promise<void>;
    /** Move column to a new index and reorder all other columns around it */
    updateReorderTokenColumn(designSystemId: string, versionId: string, view: ElementDataView, column: ElementDataViewColumn, newIndex: number): Promise<void>;
    /** Update column size */
    updateResizeTokenColumn(designSystemId: string, versionId: string, view: ElementDataView, column: ElementDataViewColumn, newWidth: number): Promise<void>;
    /** Delete theme from remote */
    deleteTokenTheme(designSystemId: string, versionId: string, themeId: string): Promise<void>;
    /** Download all necessary data for components and retrieve them resolved  */
    components(designSystemId: string, versionId: string): Promise<Array<Component>>;
    /** Download all necessary data for component groups and retrieve them resolved */
    componentGroups(designSystemId: string, versionId: string): Promise<Array<ComponentGroup>>;
    designComponents(designSystemId: string, versionId: string): Promise<Array<DesignComponent>>;
    designComponentGroups(designSystemId: string, versionId: string): Promise<Array<DesignComponentGroup>>;
    /** Write new component to remote */
    createComponent(designSystemId: string, versionId: string, component: Component): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Update existing component in remote */
    updateComponent(designSystemId: string, versionId: string, component: Component): Promise<void>;
    /** Write new component group to remote */
    createComponentGroup(designSystemId: string, versionId: string, group: ComponentGroup): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Update existing component group in remote */
    updateComponentGroup(designSystemId: string, versionId: string, group: ComponentGroup): Promise<void>;
    /** Update component property at remote */
    updateComponentPropertyValue(designSystemId: string, versionId: string, newValue: string | boolean | number, component: Component, property: ElementProperty): Promise<void>;
    /** Delete component property in remote */
    deleteComponentPropertyValue(designSystemId: string, versionId: string, valueId: string): Promise<void>;
    /** Create a custom property in remote */
    createComponentProperty(designSystemId: string, versionId: string, model: ElementPropertyCreationModel): Promise<{
        id: string;
        idInVersion: string;
    }>;
    /** Create a custom property in remote */
    updateComponentProperty(designSystemId: string, versionId: string, propertyIdInVersion: string, model: ElementPropertyUpdateModel): Promise<void>;
    /** Delete a custom property in remote */
    deleteComponentProperty(designSystemId: string, versionId: string, propertyId: string): Promise<void>;
    /** Move column to a new index and reorder all other columns around it */
    updateReorderComponentColumn(designSystemId: string, versionId: string, view: ElementDataView, column: ElementDataViewColumn, newIndex: number): Promise<void>;
    /** Update column size */
    updateResizeComponentColumn(designSystemId: string, versionId: string, view: ElementDataView, column: ElementDataViewColumn, newWidth: number): Promise<void>;
    /** Delete component from remote */
    deleteComponent(designSystemId: string, versionId: string, componentId: string): Promise<void>;
    /** Delete group from remote */
    ungroupComponentGroup(designSystemId: string, versionId: string, groupId: string): Promise<void>;
    /** Delete group from remote */
    deleteComponentGroup(designSystemId: string, versionId: string, componentGroupToDelete: ComponentGroup, components: Array<Component>, componentGroups: Array<ComponentGroup>): Promise<void>;
    /** Write the component to remote */
    writeComponentData(designSystemId: string, versionId: string, components: Array<Component>, groups: Array<ComponentGroup>, deleteComponents: Array<Component>, deleteGroups: Array<ComponentGroup>): Promise<void>;
    /** Download all necessary data for assets and retrieve them resolved */
    assets(designSystemId: string, versionId: string): Promise<Array<Asset>>;
    /** Download all necessary data for asset groups and retrieve them resolved */
    assetGroups(designSystemId: string, versionId: string): Promise<Array<AssetGroup>>;
    /** Render assets as PNG, SVG, PDF, or combinations of it */
    renderedAssets(designSystemId: string, versionId: string, assets: Array<Asset>, groups: Array<AssetGroup>, settings: RenderedAssetRequestSettings): Promise<Array<RenderedAsset>>;
    /** Retrieve the main documentation object through which all docs data can be accessed */
    documentation(workspaceId: string, designSystemId: string, versionId: string): Promise<DocumentationLegacy>;
    updateDocumentationStructure(designSystemId: string, versionId: string, model: DocumentationLegacyModel): Promise<void>;
    /** Download all necessary data for documentation items (groups and pages) and retrieve them resolved */
    documentationItems(workspaceId: string, designSystemId: string, versionId: string): Promise<Array<DocumentationLegacyItem>>;
    /** Retrieve currently deployed documentation url */
    documentationDomain(designSystemId: string, versionId: string): Promise<string | null>;
    /** Publish the documentation */
    documentationPublish(workspaceId: string, designSystemId: string, versionId: string, environment: DocumentationEnvironment): Promise<{
        status: "Queued" | "InProgress" | "Failure";
        jobId: string;
        exporterId: string;
    }>;
    pipelines(workspaceId: string): Promise<Array<Pipeline>>;
    deletePipeline(workspaceId: string, pipelineId: string): Promise<void>;
    /** Download information about current exporter custom blocks and retrieve them resolved */
    documentationExporterCustomBlocks(designSystemId: string, versionId: string): Promise<Array<ExporterCustomBlock>>;
    /** Download information about current exporter custom block variants and retrieve them resolved */
    documentationExporterCustomVariants(workspaceId: string, exporterId: string): Promise<Array<ExporterCustomBlockVariant>>;
    /** Download information about user settings (definitions) of the exporter and retrieve it resolved */
    exporterConfigurationProperties(exporterId: string, workspaceId: string, designSystemId: string): Promise<Array<ExporterConfigurationProperty>>;
    /** Download information about user settings (values) of the exporter and retrieve it resolved */
    exporterConfigurationPropertyValues(exporterId: string, designSystemId: string): Promise<Array<{
        key: string;
        value: any;
    }>>;
    /** Download information about installed exporter and retrieve it resolved */
    exporter(workspaceId: string, exporterId: string): Promise<Exporter>;
    /** Download information about all installed exporter and retrieve it resolved */
    exporters(workspaceId: string): Promise<Array<Exporter>>;
    /** Download information about documentation builds and retrieve it resolved */
    documentationBuilds(workspaceId: string, designSystemId: string, versionId: string, environment: DocumentationEnvironment, limit?: number): Promise<Array<{
        status: "InProgress" | "Success" | "Failed";
        id: string | null;
        exporterId: string | null;
    }>>;
    /** Download information about a single workspace and retrieve it resolved */
    workspace(workspaceId: string): Promise<Workspace>;
    createWorkspace(name: string, handle?: string): Promise<Workspace>;
    createVersion(designSystemId: string, model: DesignSystemVersionUpdateModel): Promise<DesignSystemVersion>;
    editVersion(designSystemId: string, versionId: string, model: DesignSystemVersionUpdateModel): Promise<void>;
    deleteVersion(designSystemId: string, versionId: string): Promise<void>;
    createBrand(designSystemId: string, versionId: any, model: BrandUpdateModel): Promise<Brand>;
    editBrand(designSystemId: string, versionId: string, brandId: string, brand: Brand): Promise<void>;
    deleteBrand(designSystemId: string, versionId: string, brandId: string): Promise<void>;
    deleteCustomDomain(designSystemId: string): Promise<void>;
    updateCustomDomain(designSystemId: string, customerDomain: string): Promise<CustomDomain>;
    /** Validate that workspace handle is available */
    validateIsWorkspaceHandleAvailable(handle: string): Promise<boolean>;
    workspaceOnboarding(workspaceId: string): Promise<WorkspaceOnboarding>;
    workspaceIPWhitelistSettings(workspaceId: string): Promise<WorkspaceIPWhitelistSettings | null>;
    workspaceNPMRegistrySettings(workspaceId: string): Promise<WorkspaceNPMRegistrySettings | null>;
    workspaceSSOSettings(workspaceId: string): Promise<WorkspaceSSOSettings | null>;
    updateWorkspaceProfile(workspaceId: string, profile: WorkspaceProfileUpdateModel): Promise<void>;
    testIpWhitelistSettings(workspaceId: string, ipWhitelistSettings: WorkspaceIPWhitelistSettingsUpdateModel): Promise<{
        accessible: boolean;
    }>;
    updateWorkspaceOnboarding(workspaceId: string, state: WorkspaceOnboardingUpdateModel): Promise<void>;
    updateWorkspaceAvatar(workspaceId: string, avatar: File): Promise<void>;
    updateWorkspaceSSOSettings(workspaceId: string, ssoSettings: WorkspaceSSOSettingsUpdateModel): Promise<void>;
    updateWorkspaceIPWhitelistSettings(workspaceId: string, ipWhitelistSettings: WorkspaceIPWhitelistSettingsUpdateModel): Promise<void>;
    updateWorkspaceNPMRegistrySettings(workspaceId: string, npmRegistrySettings: WorkspaceNPMRegistrySettingsUpdateModel): Promise<void>;
    deleteWorkspace(workspaceId: string): Promise<void>;
    deleteWorkspaceAvatar(workspaceId: string): Promise<void>;
    deleteWorkspaceNPMRegistrySettings(workspaceId: string): Promise<void>;
    /** Download information about a single design system and retrieve it resolved */
    designSystem(designSystemId: string): Promise<DesignSystem>;
    /** Download information about design systems that user has access to under a single workspace and retrieve it resolved */
    designSystems(workspaceId: any): Promise<Array<DesignSystem>>;
    /** Creates a design system */
    createDesignSystem(workspaceId: string, name: string, description?: string): Promise<DesignSystem>;
    /** Updates a design system metadata */
    updateDesignSystemMetadata(designSystemId: string, name: string, description?: string): Promise<void>;
    /** Updates a design system multibrand option */
    updateDesignSystemIsMultibrand(designSystem: DesignSystem, isMultibrand: boolean): Promise<void>;
    /** Updates a design system switcher */
    updateDesignSystemSwitcher(designSystem: DesignSystem, designSystemSwitcher: DesignSystemSwitcher): Promise<void>;
    /** Updates design system doc exporter id  */
    updateDesignSystemDocExporterId(designSystem: DesignSystem, docExporterId: string): Promise<void>;
    /** Updates a design system multibrand option */
    updateDesignSystemDocumentationSlug(designSystem: DesignSystem, docUserSlug: string): Promise<void>;
    /** Delete a design system */
    deleteDesignSystem(designSystemId: string): Promise<void>;
    /** Download information about a custom domain */
    designSystemCustomDomain(designSystemId: string): Promise<CustomDomain>;
    /** Download information about a desing system source within a design system design and retrieve it resolved */
    designSystemSource(designSystemId: string, sourceId: string): Promise<Source>;
    /** Download information about all desing system sources within a design system design and retrieve it resolved */
    designSystemSources(designSystemId: string): Promise<Array<Source>>;
    deleteFigmaSource(designSystemId: string, sourceId: string): Promise<void>;
    linkFigmaSource(designSystemId: string, brandId: string, url: string, options: {
        scopes: {
            tokens: boolean;
            components: boolean;
            assets: boolean;
            documentationFrames: boolean;
        };
        autoImport: SourceRemoteModelCloud["autoImportMode"];
        themeId: string | null;
    }): Promise<Source>;
    updateFigmaSource(designSystemId: string, sourceId: string, options: {
        scopes?: {
            tokens: boolean;
            components: boolean;
            assets: boolean;
            documentationFrames: boolean;
        };
        autoImport?: SourceRemoteModelCloud["autoImportMode"];
        themeId?: string | null;
    }): Promise<Source>;
    updateFigmaSourceClaimOwnership(designSystemId: string, sourceId: string): Promise<Source>;
    versions(designSystemId: string): Promise<Array<DesignSystemVersion>>;
    version(designSystemId: string, versionId: string): Promise<DesignSystemVersion>;
    getBrands(designSystemId: string, versionId: string): Promise<Array<Brand>>;
    getBrand(designSystemId: string, versionId: string, brandId: string): Promise<Brand>;
    getOAuthURL(service: "figma" | "bitbucket" | "github" | "gitlab" | "azure"): Promise<string>;
    deleteOAuthIntegration(userId: string, service: "figma" | "bitbucket" | "github" | "gitlab" | "azure"): Promise<void>;
    bulkUpdateTokenData(designSystemId: string, versionId: string, data: TokenUpdateTransactionData): Promise<any>;
    bulkUpdateComponentData(designSystemId: string, versionId: string, data: ComponentUpdateTransactionData): Promise<any>;
    importTokens(designSystemId: string, brandId: string, sourceId: string, sourceName: string, sourceType: "FigmaVariablesPlugin", payload: any): Promise<any>;
    getImportJob(designSystemId: string, versionId: string, jobId: string): Promise<ImportJob>;
    getImportJobs(designSystemId: string, versionId: string): Promise<Array<ImportJob>>;
    scheduleImportJobForFigmaSources(designSystemId: string, versionId: string, sourceIds: Array<string>, dryRun: boolean): Promise<ImportJob>;
    getTokenStudioData(designSystemId: string, versionId: string): Promise<object>;
    writeTokenStudioData(designSystemId: string, versionId: string, data: object): Promise<boolean>;
}
