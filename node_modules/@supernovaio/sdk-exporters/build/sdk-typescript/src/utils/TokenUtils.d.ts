import { AnyToken, BlurType, BorderPosition, BorderStyle, DTProcessedTokenNode, GradientType, ShadowType, TokenGroup, TokenTheme } from "../exports";
import { ElementProperty } from "../model/elements/SDKElementProperty";
import { TokenType } from "../model/enums/SDKTokenType";
import { BlurToken } from "../model/tokens/SDKBlurToken";
import { BorderToken } from "../model/tokens/SDKBorderToken";
import { ColorToken } from "../model/tokens/SDKColorToken";
import { BorderWidthToken, DimensionToken, DurationToken, FontSizeToken, LetterSpacingToken, LineHeightToken, OpacityToken, ParagraphSpacingToken, RadiusToken, SizeToken, SpaceToken, ZIndexToken } from "../model/tokens/SDKDimensionToken";
import { GradientToken } from "../model/tokens/SDKGradientToken";
import { ShadowToken } from "../model/tokens/SDKShadowToken";
import { FontFamilyToken, FontWeightToken, ProductCopyToken, StringToken } from "../model/tokens/SDKStringToken";
import { TextCaseToken } from "../model/tokens/SDKTextCaseToken";
import { TextDecorationToken } from "../model/tokens/SDKTextDecorationToken";
import { Token } from "../model/tokens/SDKToken";
import { AnyTokenValue, AnyMultiLayerToken, AnySingleLayerToken, BorderWidthTokenValue, ColorTokenValue, ColorValue, DimensionTokenValue, DurationTokenValue, FontFamilyTokenValue, FontSizeTokenValue, FontWeightTokenValue, LetterSpacingTokenValue, LineHeightTokenValue, OpacityTokenValue, ParagraphSpacingTokenValue, ProductCopyTokenValue, RadiusTokenValue, RawValue, SizeTokenValue, SpaceTokenValue, StringTokenValue, TextCaseTokenValue, TextDecorationTokenValue, VisibilityTokenValue, ZIndexTokenValue } from "../model/tokens/SDKTokenValue";
import { TypographyToken } from "../model/tokens/SDKTypographyToken";
import { VisibilityToken } from "../model/tokens/SDKVisibilityToken";
type TokenMapCompletenessTypeCheck<T extends {
    [key in TokenType]: AnyToken;
}> = T;
type ActualTypeToTokenMap = {
    [TokenType.color]: ColorToken;
    [TokenType.typography]: TypographyToken;
    [TokenType.blur]: BlurToken;
    [TokenType.border]: BorderToken;
    [TokenType.shadow]: ShadowToken;
    [TokenType.gradient]: GradientToken;
    [TokenType.string]: StringToken;
    [TokenType.productCopy]: ProductCopyToken;
    [TokenType.fontFamily]: FontFamilyToken;
    [TokenType.fontWeight]: FontWeightToken;
    [TokenType.textCase]: TextCaseToken;
    [TokenType.textDecoration]: TextDecorationToken;
    [TokenType.visibility]: VisibilityToken;
    [TokenType.borderWidth]: BorderWidthToken;
    [TokenType.dimension]: DimensionToken;
    [TokenType.size]: SizeToken;
    [TokenType.space]: SpaceToken;
    [TokenType.opacity]: OpacityToken;
    [TokenType.fontSize]: FontSizeToken;
    [TokenType.lineHeight]: LineHeightToken;
    [TokenType.letterSpacing]: LetterSpacingToken;
    [TokenType.paragraphSpacing]: ParagraphSpacingToken;
    [TokenType.radius]: RadiusToken;
    [TokenType.duration]: DurationToken;
    [TokenType.zIndex]: ZIndexToken;
};
type ActualTypeToTokenClassMap = {
    [TokenType.color]: typeof ColorToken;
    [TokenType.typography]: typeof TypographyToken;
    [TokenType.blur]: typeof BlurToken;
    [TokenType.border]: typeof BorderToken;
    [TokenType.shadow]: typeof ShadowToken;
    [TokenType.gradient]: typeof GradientToken;
    [TokenType.string]: typeof StringToken;
    [TokenType.productCopy]: typeof ProductCopyToken;
    [TokenType.fontFamily]: typeof FontFamilyToken;
    [TokenType.fontWeight]: typeof FontWeightToken;
    [TokenType.textCase]: typeof TextCaseToken;
    [TokenType.textDecoration]: typeof TextDecorationToken;
    [TokenType.visibility]: typeof VisibilityToken;
    [TokenType.borderWidth]: typeof BorderWidthToken;
    [TokenType.dimension]: typeof DimensionToken;
    [TokenType.size]: typeof SizeToken;
    [TokenType.space]: typeof SpaceToken;
    [TokenType.opacity]: typeof OpacityToken;
    [TokenType.fontSize]: typeof FontSizeToken;
    [TokenType.lineHeight]: typeof LineHeightToken;
    [TokenType.letterSpacing]: typeof LetterSpacingToken;
    [TokenType.paragraphSpacing]: typeof ParagraphSpacingToken;
    [TokenType.radius]: typeof RadiusToken;
    [TokenType.duration]: typeof DurationToken;
    [TokenType.zIndex]: typeof ZIndexToken;
};
export type TokenTypeMapToken = TokenMapCompletenessTypeCheck<ActualTypeToTokenMap>;
type TokenClassMapCompletenessTypeCheck<T extends {
    [key in TokenType]: new (...args: any[]) => TokenTypeMapToken[key];
}> = T;
export type TokenClassTypeMapToken = TokenClassMapCompletenessTypeCheck<ActualTypeToTokenClassMap>;
export declare class TokenUtils {
    /** Map tokens for lookup */
    static tokensToReferenceMap(tokens: Array<Token>): Map<string, Token>;
    /** Map token groups for lookup */
    static tokenGroupsToReferenceMap(groups: Array<TokenGroup>): Map<string, TokenGroup>;
    static lookupReference<T extends Token>(id: string, tokens: Map<string, Token>): T | undefined;
    /** Creates a new token group for a given token type. Default values will be used for all properties */
    static createDefaultTokenGroup(type: TokenType, versionId: string, brandId: string, name?: string): TokenGroup;
    /** Creates a new token theme. Default values will be used for all properties */
    static createDefaultTokenTheme(versionId: string, brandId: string): TokenTheme;
    /** Creates a new token for a given token type. Default values will be used for all properties */
    static createDefaultToken<T extends TokenType>(type: T, versionId: string, brandId: string, properties: Array<ElementProperty>): TokenTypeMapToken[T];
    /** Creates a new default color token */
    private static createDefaultColorToken;
    /** Creates a new default typography token */
    private static createDefaultTypographyToken;
    /** Creates a new default typography token */
    private static createDefaultGradientToken;
    /** Creates a new default dimension token */
    private static createDefaultDimensionToken;
    /** Creates a new default size token */
    private static createDefaultSizeToken;
    /** Creates a new default space token */
    private static createDefaultSpaceToken;
    /** Creates a new default opacity token */
    private static createDefaultOpacityToken;
    /** Creates a new default line height token */
    private static createDefaultLineHeightToken;
    /** Creates a new default letter spacing token */
    private static createDefaultLetterSpacingToken;
    /** Creates a new default paragraph spacing token */
    private static createDefaultParagraphSpacingToken;
    /** Creates a new default border token */
    private static createDefaultBorderWidthToken;
    /** Creates a new default border radius token */
    private static createDefaultRadiusToken;
    /** Creates a new default font size token */
    private static createDefaultFontSizeToken;
    /** Creates a new default font family token */
    private static createDefaultFontFamilyToken;
    /** Creates a new default font weight token */
    private static createDefaultFontWeightToken;
    /** Creates a new default duration token */
    private static createDefaultDurationToken;
    /** Creates a new default z-index token */
    private static createDefaultZIndexToken;
    /** Creates a new default text case token */
    private static createDefaultTextCaseToken;
    /** Creates a new default text case token */
    private static createDefaultTextDecorationToken;
    /** Creates a new default visibility token */
    private static createDefaultVisibilityToken;
    /** Creates a new default generic token */
    private static createDefaultBlurToken;
    /** Creates a new default generic token */
    private static createDefaultStringToken;
    /** Creates a new default generic token */
    private static createDefaultProductCopyToken;
    /** Creates a new default generic token */
    private static createDefaultShadowToken;
    /** Creates a new default generic token */
    private static createDefaultBorderToken;
    static replaceIdAcrossAllPossibleReferences(override: DTProcessedTokenNode, newId: string, allTokens: Array<DTProcessedTokenNode>): void;
    static replaceIdAcrossAllPossibleReferencesWithTokens(currentId: string, newId: string, allTokens: Array<Token>): void;
    static replaceIdForComplexTokens(token: AnyToken, currentId: string, newId: string): void;
    /** Creates a new theme with updated overrides */
    static tokenThemeByUpdatingOverride(theme: TokenTheme, override: AnyToken): TokenTheme;
    /** Creates a new theme with removed override */
    static tokenThemeByRemovingOverride(theme: TokenTheme, tokenId: string): TokenTheme;
    /** Creates a new color token with updated .color value */
    static colorTokenByUpdatingColor(token: ColorToken, newValue: ColorValue | ColorToken): ColorToken;
    /** Creates a new color token with updated .opacity value */
    static colorTokenByUpdatingOpacity(token: ColorToken, newValue: number | OpacityToken): ColorToken;
    /** Creates a new blur token with updated .type value */
    static blurTokenByUpdatingType(token: BlurToken, newValue: BlurType): BlurToken;
    /** Creates a new blur token with updated .radius value */
    static blurTokenByUpdatingRadius(token: BlurToken, newValue: RawValue<DimensionTokenValue> | RadiusToken): BlurToken;
    /** Creates a new typography token with updated .fontFamily value */
    static typographyTokenByUpdatingFontFamily(token: TypographyToken, newValue: RawValue<FontFamilyTokenValue> | FontFamilyToken): TypographyToken;
    /** Creates a new typography token with updated .fontWeight value */
    static typographyTokenByUpdatingFontWeight(token: TypographyToken, newValue: RawValue<FontWeightTokenValue> | FontWeightToken): TypographyToken;
    /** Creates a new typography token with updated .fontSize value */
    static typographyTokenByUpdatingFontSize(token: TypographyToken, newValue: RawValue<FontSizeTokenValue> | FontSizeToken): TypographyToken;
    /** Creates a new typography token with updated .letterSpacing value */
    static typographyTokenByUpdatingLetterSpacing(token: TypographyToken, newValue: RawValue<LetterSpacingTokenValue> | LetterSpacingToken): TypographyToken;
    /** Creates a new typography token with updated .lineHeight value */
    static typographyTokenByUpdatingLineHeight(token: TypographyToken, newValue: RawValue<LineHeightTokenValue> | LineHeightToken): TypographyToken;
    /** Creates a new typography token with updated .paragraphSpacing value */
    static typographyTokenByUpdatingParagraphSpacing(token: TypographyToken, newValue: RawValue<ParagraphSpacingTokenValue> | ParagraphSpacingToken): TypographyToken;
    /** Creates a new typography token with updated .paragraphSpacing value */
    static typographyTokenByUpdatingParagraphIndent(token: TypographyToken, newValue: RawValue<ParagraphSpacingTokenValue> | ParagraphSpacingToken): TypographyToken;
    /** Creates a new typography token with updated .textCase value */
    static typographyTokenByUpdatingTextCase(token: TypographyToken, newValue: RawValue<TextCaseTokenValue> | TextCaseToken): TypographyToken;
    /** Creates a new border token with updated .position value */
    static typographyTokenByUpdatingTextDecoration(token: TypographyToken, newValue: RawValue<TextDecorationTokenValue> | TextDecorationToken): TypographyToken;
    /** Creates a new border token with updated .color value. Do note, opacity is ignored */
    static borderTokenByUpdatingColor(token: BorderToken, newValue: ColorValue | ColorToken): BorderToken;
    /** Creates a new border token with updated color.opacity value */
    static borderTokenByUpdatingOpacity(token: BorderToken, newValue: number | OpacityToken): BorderToken;
    /** Creates a new border token with updated .width value */
    static borderTokenByUpdatingWidth(token: BorderToken, newValue: RawValue<BorderWidthTokenValue> | BorderWidthToken): BorderToken;
    /** Creates a new border token with updated .position value */
    static borderTokenByUpdatingPosition(token: BorderToken, newValue: BorderPosition): BorderToken;
    /** Creates a new border token with updated .style value */
    static borderTokenByUpdatingStyle(token: BorderToken, newValue: BorderStyle): BorderToken;
    /** Creates a new dimension token with updated value */
    static dimensionTokenByUpdatingValue(token: DimensionToken, newValue: RawValue<DimensionTokenValue>): DimensionToken;
    /** Creates a new size token with updated value */
    static sizeTokenByUpdatingValue(token: SizeToken, newValue: RawValue<SizeTokenValue>): SizeToken;
    /** Creates a new space token with updated value */
    static spaceTokenByUpdatingValue(token: SpaceToken, newValue: RawValue<SpaceTokenValue>): SpaceToken;
    /** Creates a new opacity token with updated value */
    static opacityTokenByUpdatingValue(token: OpacityToken, newValue: RawValue<OpacityTokenValue>): OpacityToken;
    /** Creates a new font size token with updated value */
    static fontSizeTokenByUpdatingValue(token: FontSizeToken, newValue: RawValue<FontSizeTokenValue>): FontSizeToken;
    /** Creates a new font size token with updated value */
    static lineHeightTokenByUpdatingValue(token: LineHeightToken, newValue: RawValue<LineHeightTokenValue>): LineHeightToken;
    /** Creates a new letter spacing token with updated value */
    static letterSpacingTokenByUpdatingValue(token: LetterSpacingToken, newValue: RawValue<LetterSpacingTokenValue>): LetterSpacingToken;
    /** Creates a new paragraph spacing token with updated value */
    static paragraphSpacingTokenByUpdatingValue(token: ParagraphSpacingToken, newValue: RawValue<ParagraphSpacingTokenValue>): ParagraphSpacingToken;
    /** Creates a new border width token with updated value */
    static borderWidthTokenByUpdatingValue(token: BorderWidthToken, newValue: RawValue<BorderWidthTokenValue>): BorderWidthToken;
    /** Creates a new radius token with updated value */
    static radiusTokenByUpdatingValue(token: RadiusToken, newValue: RawValue<RadiusTokenValue>): RadiusToken;
    /** Creates a new duration token with updated value */
    static durationTokenByUpdatingValue(token: DurationToken, newValue: RawValue<DurationTokenValue>): DurationToken;
    /** Creates a new z-index token with updated value */
    static zIndexTokenByUpdatingValue(token: ZIndexToken, newValue: RawValue<ZIndexTokenValue>): ZIndexToken;
    /** Creates a new string token with updated value */
    static stringTokenByUpdatingValue(token: StringToken, newValue: RawValue<StringTokenValue>): StringToken;
    /** Creates a new product copy token with updated value */
    static productCopyTokenByUpdatingValue(token: ProductCopyToken, newValue: RawValue<ProductCopyTokenValue>): ProductCopyToken;
    /** Creates a new font family token with updated value */
    static fontFamilyTokenByUpdatingValue(token: FontFamilyToken, newValue: RawValue<FontFamilyTokenValue>): FontFamilyToken;
    /** Creates a new font weight token with updated value */
    static fontWeightTokenByUpdatingValue(token: FontWeightToken, newValue: RawValue<FontWeightTokenValue>): FontWeightToken;
    /** Creates a new text case token with updated value */
    static textCaseTokenByUpdatingValue(token: TextCaseToken, newValue: RawValue<TextCaseTokenValue>): TextCaseToken;
    /** Creates a new text case token with updated value */
    static textDecorationTokenByUpdatingValue(token: TextDecorationToken, newValue: RawValue<TextDecorationTokenValue>): TextDecorationToken;
    /** Creates a new visibility token with updated value */
    static visibilityTokenByUpdatingValue(token: VisibilityToken, newValue: RawValue<VisibilityTokenValue>): VisibilityToken;
    /** Creates a new shadow token with one new extra layer added at the end of all layers */
    static shadowTokenByAddingLayer(token: ShadowToken): ShadowToken;
    /** Creates a new shadow token by removing one of the layers */
    static shadowTokenByRemovingLayer(token: ShadowToken, layerIndex: number): ShadowToken;
    /** Creates a new shadow token with updated .color value. Do note, opacity is ignored */
    static shadowTokenByUpdatingColor(token: ShadowToken, layerIndex: number, newValue: ColorValue | ColorToken): ShadowToken;
    /** Creates a new shadow token with updated .color value */
    static shadowTokenByUpdatingOpacity(token: ShadowToken, layerIndex: number, newValue: number | OpacityToken): ShadowToken;
    /** Creates a new shadow token with updated .x value */
    static shadowTokenByUpdatingX(token: ShadowToken, layerIndex: number, newValue: number): ShadowToken;
    /** Creates a new shadow token with updated .y value */
    static shadowTokenByUpdatingY(token: ShadowToken, layerIndex: number, newValue: number): ShadowToken;
    /** Creates a new shadow token with updated .radius value */
    static shadowTokenByUpdatingRadius(token: ShadowToken, layerIndex: number, newValue: number): ShadowToken;
    /** Creates a new shadow token with updated .spread value */
    static shadowTokenByUpdatingSpread(token: ShadowToken, layerIndex: number, newValue: number): ShadowToken;
    /** Creates a new shadow token with updated .type value */
    static shadowTokenByUpdatingType(token: ShadowToken, layerIndex: number, newValue: ShadowType): ShadowToken;
    /** Creates a new gradient token with updated .to value */
    static gradientTokenByUpdatingTo(token: GradientToken, layerIndex: number, newValue: {
        x: number;
        y: number;
    }): GradientToken;
    /** Creates a new gradient token with updated .from value */
    static gradientTokenByUpdatingFrom(token: GradientToken, layerIndex: number, newValue: {
        x: number;
        y: number;
    }): GradientToken;
    /** Creates a new gradient token with updated .to value */
    static gradientTokenByUpdatingType(token: GradientToken, layerIndex: number, newValue: GradientType): GradientToken;
    /** Creates a new gradient token with updated .aspectRatio value */
    static gradientTokenByUpdatingAspectRatio(token: GradientToken, layerIndex: number, newValue: number): GradientToken;
    /** Creates a new gradient token with updated .to value */
    static gradientTokenByUpdatingStops(token: GradientToken, layerIndex: number, newValue: Array<{
        position: number;
        color: ColorTokenValue | ColorToken;
    }>): GradientToken;
    /** Creates a new token where value is reference to the provided token. Token and reference must be of the same type */
    static tokenByReferencing<T extends AnyToken>(token: T, reference: T): T;
    /** Creates a new multilayer token where one of the layers is reference to the provided token. Token and reference must be of the same type */
    static multilayerTokenByReferencing<T extends AnyMultiLayerToken>(token: T, layerIndex: number, reference: T): T;
    /** Creates a new token where value is raw, but taken from the previously referenced token. Token must have had reference before */
    static tokenByDisconnectingReference<T extends AnySingleLayerToken>(token: T, options?: {
        supressErrorOnNoReference?: boolean;
    }): T;
    /** Creates a new multilayer token where one of the layers value is raw, but taken from the previously referenced token. That layer must have had reference before */
    static multilayerTokenByDisconnectingReference<T extends AnySingleLayerToken>(token: T, layerIndex: number): T;
    /** Checks if token as a whole is a reference to another token */
    static isReferencedToken(token: AnySingleLayerToken): boolean;
    /** Checks if a token layer of multilayer token is a reference to another token */
    static isReferencedMultilayerTokenLayer(token: AnyMultiLayerToken, layerIndex: number): boolean;
    /** Checks if a token was imported from some foreign source. Not imported tokens were always created in Supernova */
    static isTokenImported(token: AnyToken): boolean;
    private static checkNotReference;
    private static rawOrReferencedDimensionValue;
    private static rawOrReferencedStringValue;
    private static validateLayerAccess;
    static inlineValueIntoComplexTokens(token: AnyToken, candidateId: string, candidateValueToInline: AnyTokenValue): void;
    static getRefIdsFromComplexTokens(token: AnyToken): string[];
    static buildKey(path: Array<string>, name: string): string;
    static buildPath(token: Token, groups: Array<TokenGroup>): Array<string>;
    static mapTypeToPrefix: (type: TokenType) => string;
    static mapTypeToPrefixBack: (type: TokenType) => string;
    static mapTypeToPrefix2: (type: TokenType) => string;
    static buildFallbackKey(node: Pick<DTProcessedTokenNode, 'path' | 'token'>): string;
    static buildFallbackKeyBack(node: Pick<DTProcessedTokenNode, 'path' | 'token'>): string;
    static buildFallbackKey2(node: Pick<DTProcessedTokenNode, 'path' | 'token'>): string;
    static getTokenByKeyOrFallbackKeys<T extends DTProcessedTokenNode | Token>(node: Pick<DTProcessedTokenNode, 'path' | 'token'>, map: Map<string, T>): T | undefined;
    static getKeysByKeyOrFallbackKeys<T extends DTProcessedTokenNode | Token>(node: Pick<DTProcessedTokenNode, 'path' | 'token'>): string[];
    static getTokenByKeyOrBackwardKey(node: Pick<DTProcessedTokenNode, 'path' | 'token'>, map: Map<string, DTProcessedTokenNode>): DTProcessedTokenNode | undefined;
}
export {};
