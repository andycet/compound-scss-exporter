import { TokenGroup } from "../../../model/groups/SDKTokenGroup";
import { Token } from "../../../model/tokens/SDKToken";
import { AnyOptionTokenValue, AnyStringTokenValue, BorderTokenValue, ColorTokenValue, DimensionTokenValue, GradientTokenValue, ShadowTokenValue, TypographyTokenValue } from "../../../model/tokens/SDKTokenValue";
import { TokenJSONBuilderOptionsInternal } from "../SDKToolsJSONBuilder";
import { TokenJSONElementTransformer } from "./SDKToolsJSONElementTransformer";
/** Token transformer that allow generic transform of tokens to different destinations, like Style Dictionary or Figma Tokens representation */
export declare class TokenJSONElementFigmaTokensTransformer extends TokenJSONElementTransformer {
    /** Represent color token value either as reference or as plain representation */
    representColorTokenValue(value: ColorTokenValue, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Represent dimension token value either as reference or as plain representation */
    representDimensionTokenValue(value: DimensionTokenValue, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Represent text token value either as reference or as plain representation */
    representStringTokenValue(value: AnyStringTokenValue, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    representOptionTokenValue(value: AnyOptionTokenValue, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Represent typography token value either as reference or as plain representation */
    representTypographyTokenValue(value: TypographyTokenValue, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Represent border token value either as reference or as plain representation */
    representBorderTokenValue(value: BorderTokenValue, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Represent shadow token value either as reference or as plain representation */
    representShadowTokenValue(values: ShadowTokenValue[], allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Represent gradient token value either as reference or as plain representation */
    representGradientTokenValue(values: GradientTokenValue[], allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): any;
    /** Retrieve token wrapper containing its metadata and value information (used as container for each defined token) */
    tokenWrapper(token: Token, value: any, options: TokenJSONBuilderOptionsInternal, groups: Array<TokenGroup>): object;
    /** Retrieve human-readable token type in unified fashion, used both as token type and as token master group */
    typeLabelConsideringAbstractGroups(token: Token, groups: Array<TokenGroup>): string;
    /** Retrieve wrapper to certain token (referenced by name) pointing to token value */
    referenceWrapper(reference: string): string;
    /** Retrieve safe group name made out of normal group name
     * This replace spaces with dashes, also change anything non-alphanumeric char to it as well.
     * For example, ST&RK Industries will be changed to st-rk-industries
     */
    safeGroupName(group: TokenGroup): string;
    /** Create full reference name representing token. Such name can, for example, look like: [g1].[g2].[g3].[g4].[token-name] */
    referenceName(referenceId: string, allTokens: Map<string, Token>, allGroups: Array<TokenGroup>, options: TokenJSONBuilderOptionsInternal): string;
    groupIsAbstract(group: TokenGroup, allGroups: Array<TokenGroup>): boolean;
}
