import { Supernova } from "../../core/SDKSupernova";
import { Brand } from "../../model/base/SDKBrand";
import { TokenGroup } from "../../model/groups/SDKTokenGroup";
import { TokenTheme } from "../../model/themes/SDKTokenTheme";
import { Token } from "../../model/tokens/SDKToken";
import { AnyToken } from "../../model/tokens/SDKTokenValue";
import { DTProcessedTokenNode } from "./utilities/SDKDTJSONConverter";
import { DTPluginToSupernovaMap, DTPluginToSupernovaMapPack, DTPluginToSupernovaSettings } from "./utilities/SDKDTMapLoader";
import { DTTokenMergeDiff } from "./utilities/SDKDTTokenMerger";
export type SupernovaToolsDesignTokensLoadingResult = {
    processedNodes: Array<DTProcessedTokenNode>;
    tokens: Array<Token>;
    groups: Array<TokenGroup>;
};
export type SupernovaToolsDesignTokensResult = {
    map: Pick<DTPluginToSupernovaMap, "bindToBrand" | "bindToTheme" | "pluginSets" | "pluginTheme" | "type">;
    tokensCreated: Array<string>;
    tokensUpdated: Array<string>;
    tokensDeleted: Array<string>;
};
/** Design Tokens Plugin Manipulation Tool */
export declare class SupernovaToolsDesignTokensPlugin {
    private instance;
    private designSystemId;
    private versionId;
    private sortMultiplier;
    constructor(designSystemId: string, versionId: string, instance: Supernova);
    synchronizeTokensFromData(data: object, mapping: DTPluginToSupernovaMapPack, settings: DTPluginToSupernovaSettings): Promise<boolean>;
    synchronizeTokensFromDataWithResults(data: object, mapping: DTPluginToSupernovaMapPack, settings: DTPluginToSupernovaSettings): Promise<SupernovaToolsDesignTokensResult[]>;
    private processTokenNodes;
    private setTokensOrigin;
    /** Creates pure tree for validation purposes, ignoring any existing token state in workspaces. This method works offline. */
    createPureTokenTree(processedNodes: Array<DTProcessedTokenNode>, verbose: boolean): {
        tokens: Array<AnyToken>;
        groups: Array<TokenGroup>;
    };
    /** Loads remote source connected to this tool, then merges tokens and groups with it, creating union. Can optionally write to the source as well */
    mergeWithRemoteSource(processedNodes: Array<DTProcessedTokenNode>, brand: Brand, write: boolean, verbose: boolean, preciseCopy: boolean): Promise<{
        tokens: Array<Token>;
        groups: Array<TokenGroup>;
        diff: DTTokenMergeDiff;
    }>;
    /** Loads remote source connected to this tool, then creates the diff from the base tree and updates the associated theme. Can optionally write to the source as well */
    mergeThemeWithRemoteSource(processedNodes: Array<DTProcessedTokenNode>, brand: Brand, theme: TokenTheme, write: boolean, verbose: boolean, preciseCopy?: boolean): Promise<{
        theme: TokenTheme;
        tokens: Array<Token>;
    }>;
    correctSortOrder(tokens: Array<Token>, tokenGroups: Array<TokenGroup>): void;
    correctSortOrderFromTypeRoot(root: TokenGroup, tokenMap: Map<string, Token>, groupMap: Map<string, TokenGroup>): void;
    flattenedIdsFromRoot(root: TokenGroup, tokenMap: Map<string, Token>, groupMap: Map<string, TokenGroup>): Array<string>;
}
